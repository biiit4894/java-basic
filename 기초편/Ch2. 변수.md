# Chapter 2 변수

# 03 변수의 선언과 저장

변수는 오직 하나의 값만 저장할 수 있기 때문에, 이미 값이 저장된 변수에 새로운 값을 저장하면 기존의 값은 지워지고 새로 저장된 값만 남는다. 변수의 선언과 대입을 한 줄로 간단히 할 수도 있다.

```jsx
int x; // 변수의 선언
x = 5; // 변수에 대입

// 동일한 한 줄
int x = 5;
```

# 04 변수의 타입

변수를 선언할 때, 변수에 저장할 값의 종류에 따라 변수의 타입을 선택해야 한다. 변수의 타입은 참조형과 8개의 기본형이 있는데, 일단 자주 쓰이는 타입만 소개한다.

- 숫자형
  - int : 정수를 저장하기 위한 타입(20억이 넘을 땐 long)
  - long
  - float : 실수(floating-point number)를 저장하기 위한 타입. float는 오차없이 7자리, double은 15자리
  - double
- 문자형
  - char : 문자(character)를 저장하기 위한 타입
  - String: 여러 문자(문자열, string)를 저장하기 위한 타입

이 중에서 아래 4개의 타입만 알아도 프로그래밍을 배우는데 큰 지장이 없다. 각 타입의 변수를 선언한 예는 다음과 같다.

```jsx
int x = 100;        // 정수(integer)를 저장할 변수의 타입은 int로 한다
double pi = 3.14;   // 실수를 저장할 변수의 타입은 double로 한다.
char ch = 'a';      // 문자(1개)를 저장할 변수의 타입은 char로 한다.
String str = "abc"  // 여러 문자(0~n개)를 저장할 변수의 타입은 String으로 한다.
```

이처럼 변수를 선언할 때 변수의 타입은 변수에 저장할 값의 종류에 맞게 선택해야 한다.

# 05 상수와 리터럴

- 상수(constant) : 변수처럼 값을 저장할 수 있는 공간은 맞지만 한번 값을 저장하면 다른 값으로 변경 불가.
  - `final 변수타입 변수명`
- 상수에 값이 저장된 후에는 상수의 값을 변경하는 것이 허용되지 않음
  ```jsx
  final int MAX_VALUE; // 정수형 상수 MAX_VALUE를 선언
  MAX_VALUE = 100;     // OK. 상수에 처음으로 값 저장.
  MAX_VALUE = 200;     // 에러. 상수에 저장된 값 변경 불가.
  ```
- 상수 이름은 모두 대문자로, 여러 단어면 언더바( \_ )로 구분

## 변수vs상수vs리터럴

- 변수(variable) : 하나의 값을 저장하기 위한 공간
- 상수(constant) : 값을 한번만 저장할 수 있는 공간
- 리터럴(literal) : 그 자체로 값을 의미함.
  - 상수의 다른 이름일 뿐!
  ```jsx
  int year = 2014;
  final int MAX_VALUE = 100;
  // 2014, 100이 모두 리터럴에 해당한다.
  // year는 변수, MAX_VALUE는 상수
  ```

# 06 리터럴의 타입과 접미사

변수의 타입은 저장될 값의 타입(리터럴의 타입)에 의해 결정된다. 만약 리터럴에 타입이 없다면 변수의 타입도 필요없을 것이다.

| 종류   | 리터럴                       | 접미사 |
| ------ | ---------------------------- | ------ |
| 논리형 | false, true                  | 없음   |
| 정수형 | 123, 0b0101, 077, 0xFF, 100L | L      |
| 실수형 | 3.14, 3.0e8, 1.4f, 0x1.0p-1  | f, d   |
| 문자형 | ‘A’, ‘1’, ‘\n’               | 없음   |
| 문자열 | “ABC”, “123”, “A”, “true”    | 없음   |

정수형과 실수형에는 여러 타입이 존재하므로, 리터럴에 접미사를 붙여서 타입을 구분한다.

- 정수형
  - long 타입 리터럴 + l / L
  - int 타입 리터럴은 접미사 없음
  - byte, short 타입 변수에 값을 저장할 때는 int 타입의 리터럴 사용

2, 8, 16진수 리터럴을 변수에 저장할 수 있고, 리터럴 사용은 다음과 같음

- ‘0x’ / ‘0X’ + 16진수 리터럴
- ‘0’ + 8진수 리터럴
  ```jsx
  int octNum = 010; // 8진수 10, 10진수로 8
  int hexNum = 0x10; // 16진수 10, 10진수로 16
  ```

JDK1.7부터는 정수형 리터럴 중간에 ‘ \_ ‘를 넣을 수 있음

```jsx
long big = 100_000_000_000L; // long big = 100000000000L;
long hex = 0xFFFF_FFFF_FFFF_FFFFL; // long hx = 0xFFFFFFFFFFFFFFFFL
```

실수형에서는 float 타입의 리터럴에 접미사 ‘f’ 또는 ‘F’를 붙이고, double 타입의 리터럴에는 접미사 ‘d’ 또는 ‘D’를 붙인다.

```jsx
float pi = 3.14f;      // 접미사 f 대신 F를 사용해도 된다. 생략불가
double rate = 1.618d;  // 접미사 d 대신 D를 사용해도 된다. 생략가능
```

# 07 문자 리터럴과 문자열 리터럴

‘A’와 같이 작은따옴표로 **문자 하나**를 감싼 것을 **‘문자 리터럴’**이라고 한다. **두 문자 이상**은 큰 따옴표로 감싸야 하며 **‘문자열 리터럴’**이라고 한다.

```jsx
char ch = 'J';         // char ch = 'Java'; 이렇게 X
String name = "Java";  // 변수 name에 문자열 리터럴 "Java"를 저장
```

- char 타입 - 단 하나의 문자만 저장
  - `' '` 안에 하나의 문자 필요
- String 타입 - 여러 문자(문자열)를 저장
  - 빈 문자열 허용
  - `" "` OK

```jsx
String str = ""; // OK. 빈 문자열
char ch = '';    // 에러.
char ch = ' ';   // OK. 공백 문자.
```

원래 String은 클래스라서 객체 생성 연산자 `new`를 사용해야 하지만, 이와 같은 표현도 허용한다.

```jsx
String name = new String("Java"); // String 객체를 생성
String name = "Java";  // 위의 문장을 간단히 표현.
```

# 08 문자열 결합

문자열 + **any type** → 문자열 + **문자열** ⇒ 문자열

**any type** + 문자열 → **문자열** + 문자열 ⇒ 문자열

```jsx
7 + 7 + "" -> 14 + "" -> "14" + "" -> "14"
"" + 7 + 7 -> "7" + 7 -> "7" + "7" -> "77"
```

숫자 n을 문자열 “n”으로 변환하고 싶으면 빈 문자열(`""`)을 더해주면 된다.

# 09 두 변수의 값 바꾸기

```java
int x = 10;
int y = 20;
```

x와 y에 저장된 값을 바꾸려면 값을 임시로 저장할 변수가 필요하다.

```java
int x = 10;
int y = 20;

int tmp;
tmp = x;
x = y;
y = tmp;
```

# 10 기본형과 참조형

- 자료형(data type) : 값(data)의 종류(type)에 따라 값이 저장될 공간의 크기와 저장 형식을 정의한 것.
- 자료형
  - 문자형(char)
  - 정수형(byte, short, int, long)
  - 실수형(float double)

## 기본형과 참조형

- 기본형(primitive type)
  - 실제 값(data)을 저장
  - 자바는 참조형 변수 간의 연산을 할 수 없어서 기본형 변수만 실제 연산에 사용됨.
- 참조형(reference type)
  - 어떤 값이 저장되어 있는 주소(memory address)를 값으로 가짐
- 자료형(data type)과 타입(type)의 차이?
  - 타입이 자료형을 포함하는 넓은 의미의 용어.
  - 기본형의 종류 구분 → 자료형
  - 참조형의 종류 구분 → 타입

# 11 기본형의 종류와 범위

|        | 1 byte  | 2 byte | 4 byte | 8 byte |
| ------ | ------- | ------ | ------ | ------ |
| 논리형 | boolean |        |        |        |
| 문자형 |         | char   |        |        |
| 정수형 | byte    | short  | int    | long   |
| 실수형 |         |        | float  | double |

- 정수형의 경우 ‘-2^(n-1) ~ 2^(n-1) - 1’ (n은 bit수)
  - ex) int형은 4 byte = 32 bit = ‘-2^31~2^31-1’의 범위를 갖는다.

# 12 printf를 이용한 출력

- `println()` : 변수의 값을 그대로 출력하기 때문에 값을 변환하지 않고는 다른 형식으로 출력할 수 없음.
  - appends a newline character
- `printf()` : 지시자(specifier)를 통해 변수의 값을 여러 가지 형식으로 변환하여 출력하는 기능을 가지고 있다.
  - print formatted
  | 지시자 | 설명                                        |
  | ------ | ------------------------------------------- |
  | %d     | 10진(decimal) 정수의 형식으로 출력          |
  | %x     | 16진(hexa-decimal) 정수의 형식으로 출력     |
  | %f     | 부동 소수점(floating-point)의 형식으로 출력 |
  | %c     | 문자(character)로 출력                      |
  | %s     | 문자열(string)로 출력                       |
  - 줄바꿈 시 지시자 ‘`%n`’ 또는 ‘`\n`’을 따로 넣어준다.
  - `%n`을 더 추천함.

# 13 printf를 이용한 출력 예제

- 실수형 값의 출력에 사용되는 지시자
  - `%f` : 주로 쓰이는 형태
    - 실수를 출력할 때 기본적으로 사용
  - `%e` : 지수 형태로 출력할때 쓰임
    - 숫자에 0이 많을 때
  - `%g` : 값을 간략하게 표현할 때 쓰임
- 지시자 ‘`%s`’에도 숫자를 추가하면 원하는 만큼의 출력공간을 확보하거나 문자열의 일부만 출력할 수 있다.

# 14 화면으로부터 입력받기

# 15 정수형의 오버플로우

- ********************************************\*\*********************************************오버플로우 : 타입이 표현할 수 있는 값의 범위를 넘어서는 것********************************************\*\*********************************************

  - 오버플로우가 발생하면 무조건 에러가 발생하는 것 x, but 예상 못한 결과 나올 수 있으니 애초에 충분한 크기의 타입을 선택해야

- 부호없는 정수는 2진수로 ‘0000’이 될 때 오버플로우 발생
- 부호있는 정수는 부호비트가 0에서 1이 될 때 오버플로우 발생
- short : 부호 있는 정수
- char : 부호 없는 정수
- 둘 다 대략 6만여개의 값을 표현할 수 있는데, short는 절반 가까이를 부호 있는 정수 표현에 쓴다.
