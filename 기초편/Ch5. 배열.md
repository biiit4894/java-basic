# 배열이란?

- 같은 타입의 여러 변수를 하나의 묶음으로 다루는 것

# 배열의 선언, 생성

- 선언은 두 방법 다 무관함
  - 타입[] 변수이름;
  - 타입 변수이름[];
- 생성법
  - 타입[] 변수이름; // 배열을 다루는 참조변수를 위한 공간
    ****************\*\*****************변수이름 = new 타입[길이]; // 비로소 실제 값의 저장공간이 생김****************\*\*****************
- 선언과 생성을 동시에 하기
  - 타입[] 변수이름 = new 타입[길이];

# 배열의 초기화

- 타입[] 변수이름 = new 타입[] { 저장할 값 쉼표로 나열 가능 }
- 타입[] 변수이름 = { 저장할 값 쉼표로 나열 가능 }

# 배열의 출력

- Arrays.toString(배열이름)

# String 배열

- String타입 참조형 변수 ??
  - 참조형의 기본값은 null
- 원래 String을 클래스라 new 연산자로 객체를 생성하는 것이 맞음. 그러나 String 타입만 생략이 허용된다.
  ```java
  String[] 변수명 = new String[??];
  변수명[0] = new String("어쩌구"); // new String 생략허용
  ...
  변수명[??] = new String("저쩌구")'
  ```

# String클래스

- 문자열은 문자배열인 char배열이나 다름없음
- char배열을 바로 쓰지는 않고 거기에 여러 기능(메서드)를 추가한 String클래스로 문자열을 처리함
- 객체지향언어는 서로 관련된 데이터와 기능을 클래스에 묶는다. 이전에는 데이터와 기능이 분리되었음. 이때 기능 = 함수 = 메서드
- String객체는 읽을수는 있지만 내용은 변경 불가하기 때문에 바뀐것같다? 그러면 그건 사실 아예 새로운 문자열이 생겨서 그렇게 보이는 것임.

```java
// 메서드
char charAt(int index) // 한 문자만 가져옴
int length()
String substring(int from, int to) // 마지막 index는 범위 미포함
boolean equals(Object obj) // 대소문자구분 없이 비교는 equalsIgnoreCase()
char[] toCharArray()

```

# 커맨드 라인을 통해 입력받기

- String배열에 담겨서 main 클래스의 argument로 전달됨. 인덱스로 접근 가능.
- 매개변수를 cmd에서 써주지 않으면 크키가 0인 배열 생성.

# 2차원 배열의 선언과 초기화

2차원 배열은 1차원 배열 여러개의 참조변수들을 또 하나의 배열로 묶은 것. 배열의 배열임.

## 선언

- **타입[][] 변수이름;**
- 타입 변수이름[][];
- 타입[] 변수이름[];
- 배열 선언 시 배열의 각 요소(저장공간)에는 배열요소가 가진 타입의 기본값이 자동으로 저장됨

## 초기화

- 타입[][] 변수이름 = new 변수이름[][] { { ??, ??, …, ?? }, { ??, ??, …, ?? } }
- 타입[][] 변수이름 = { { ??, ??, …, ?? }, { ??, ??, …, ?? } }

또는

```java
타입[][] 변수이름 = {
		{1, 2, 3},
		{4, 5, 6}
};
```
