# Chapter 3 연산자

# 02 연산자의 종류

| 종류        | 연산자                | 설명                                         |
| ----------- | --------------------- | -------------------------------------------- | ---------- | --- |
| 산술 연산자 | + - \* / % << >>      | 사칙 연산과 나머지 연산                      |
| 비교 연산자 | > < ≥ ≤ == ≠          |                                              |
| 논리 연산자 | &&                    |                                              | ! & ㅣ ^ ~ |     |
| 대입 연산자 | =                     |                                              |
| 기타        | (type) ? : instanceof | 형변환 연산자, 삼항 연산자, instanceof연산자 |

# 04 연산자의 결합규칙

- 산술 > 비교 > 논리 > 대입. (대입이 가장 마지막에 수행됨
- 단항 > 이항 > 삼항 (단항 연산자의 우선순위가 이항 연산자보다 높다)
- **단항 연산자, 대입 연산자**를 제외한 모든 연산은 **왼 → 오**로 진행

# 05 증감 연산자 ++과 —

- 전위형(prefix)
  - 값이 참조되기 전에 증가시킴
    ex) x = ++i; → 증가 후에 참조하여 대입
- 후위형(postfix)
  - 값이 참조된 **\*\***후에**\*\*** 증가시킴
    ex) x = i++; → 참조하여 대입한 후에 증가
- 증감연산자가 수식이나 메서드 호출에 포함되지 않고 그냥 한 문장으로 쓰이면 차이 없음

# 06 부호 연산자

- 부호 연산자는 boolean형, char형을 제외한 기본형에만 사용할 수 있음.

# 08 자동 형변환

- 생략된 형변환은 컴파일러가 자동적으로 추가해줌
  - ex) float f = 1234; // float f = (float)1234; 에서 캐스트(형변환) 연산자가 생략된 것
- 저장할 수 있는 값의 범위보다 더 큰 값을 저장하려는 경우 형변환을 생략하면 에러가 발생함
  - ex) byte b = 1000; // byte 타입의 범위(-128~127)를 벗어남 → 에러
  - ex) byte b = (byte)1000; // OK. 값 손실, -24 저장
- 기존의 값을 최대한 보존할 수 있는 타입으로 자동 형변환
- 표현범위 좁 > 넓으로의 형변환 → 값 손실 없음

# 09 사칙 연산자

- 피연산자가 정수형인 경우, 0으로 나눌 수 없음. 0으로 나누면 에러 발생
- 10 / 4.0f → 10.0f / 4.0f → 2.5f

# 10 산술 변환

1. 두 피연산자의 타입을 보다 큰 타입으로 일치시키기
2. 피연산자의 타입이 int보다 작은 타입이면 int로 변환됨

- 연산결과의 타입은 피연산자의 타입과 동일
- 산술 변환 = 연산 직전에 발생하는 자동 형변환
- 작은 자료형의 변수 → 큰 자료형의 변수
  - 저장 시 자동 형변환
- 큰 자료형의 변수 → 작은 자료형의 변수
  - 명시적 형변환 필요

# 11 Math.round()로 반올림하기

- Math.round()
  - 소수점 첫째 자리에서 반올림한 결과를 정수로 반환
  - 다른 자리에서 반올림 하려면 10의 n승 적절히 곱해주고 나눠주기
